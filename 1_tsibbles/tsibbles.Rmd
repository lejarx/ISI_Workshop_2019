---
title: "High dimensional time series analysis"
date: "robjhyndman.com/hdtsa"
author: "1. Tidy time series tsibbles"
toc: true
output:
  binb::monash:
    colortheme: monashwhite
    fig_width: 7
    fig_height: 3.5
    includes:
      in_header: ../header.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(fpp3)

global_economy <- global_economy %>%
  select(Year, Country, GDP, Imports, Exports, Population)
tourism <- tourism %>%
  mutate(
    State = recode(State,
                   "Australian Capital Territory" = "ACT",
                   "New South Wales"="NSW",
                   "Northern Territory" = "NT",
                   "Queensland" = "QLD",
                   "South Australia" = "SA",
                   "Tasmania" = "TAS",
                   "Victoria"="VIC",
                   "Western Australia" = "WA"
    )
  )
```

# Time series data

## Tidyverts packages

\begin{textblock}{3.8}(8,0)\begin{alertblock}{}\Large\textbf{tidyverts.org}\end{alertblock}\end{textblock}

\placefig{1}{1.4}{width=4cm}{tsibble.png}
\placefig{5}{1.4}{width=4cm}{tsibbledata.png}
\placefig{3}{4.85}{width=4cm}{feasts.png}
\placefig{7}{4.85}{width=4cm}{fable.png}



## Time series data

  - Four-yearly Olympic winning times
  - Annual Google profits
  - Quarterly Australian beer production
  - Monthly rainfall
  - Weekly retail sales
  - Daily IBM stock prices
  - Hourly electricity demand
  - 5-minute freeway traffic counts
  - Time-stamped stock transaction data

## Class packages
\fontsize{13}{15}\sf

```r
# Data manipulation and plotting functions
library(tidyverse)
# Time series manipulation
library(tsibble)
# Forecasting functions
library(fable)
# Time series graphics and statistics
library(feasts)
# Tidy time series data
library(tsibbledata)
```

## `tsibble` objects

\fontsize{10}{11.2}\sf

```{r, echo = TRUE}
global_economy
```

\only<2->{\begin{textblock}{.75}(2.15,3.7)
\begin{alertblock}{}\fontsize{10}{10}\sf Index\phantom{dg}\end{alertblock}
\end{textblock}}
\only<3->{\begin{textblock}{1.6}(3.28,3.7)
\begin{alertblock}{}\fontsize{10}{10}\sf Key\phantom{dg}\end{alertblock}
\end{textblock}}
\only<4>{\begin{textblock}{6.7}(5.5,3.7)
\begin{alertblock}{}\fontsize{10}{10}\sf Measured variables\phantom{dg}\end{alertblock}
\end{textblock}}


## `tsibble` objects

\fontsize{10}{11.3}\sf

```{r, echo = TRUE}
tourism
```

\only<2->{\begin{textblock}{1.1}(2.1,3.7)
\begin{alertblock}{}\fontsize{10}{10}\sf Index\phantom{dg}\end{alertblock}
\end{textblock}}
\only<3->{\begin{textblock}{3.9}(3.65,3.7)
\begin{alertblock}{}\fontsize{10}{10}\sf Keys\phantom{dg}\end{alertblock}
\end{textblock}}
\only<4-5>{\begin{textblock}{1.5}(7.95,3.7)
\begin{alertblock}{}\fontsize{10}{10}\sf Measure\phantom{dg}\end{alertblock}
\end{textblock}}

\only<5>{\begin{textblock}{3}(9,5)
\begin{block}{}\fontsize{10}{10}\sf Domestic visitor nights in thousands by state/region and purpose.\phantom{dg}\end{block}
\end{textblock}}


## `tsibble` objects

A `tsibble` allows storage and manipulation of time series in R.

It contains:

- Measured variable(s): numbers of interest
- An index: time information about the observation
- Key variable(s): optional unique identifiers for each series

## The `tsibble` index

### Example
\fontsize{13}{15}\sf

```{r tstable, cache=TRUE}
library(tsibble)
y <- tsibble(year = 2012:2016,
  y = c(123,39,78,52,110), index = year)
y
```

## The `tsibble` index

\begin{block}{}
For observations more frequent than once per year, we need to use a time class function on the index.
\end{block}

```{r tstablemonth, echo=FALSE}
z <- tibble(Month = paste(2019, month.abb[1:5]), Observation = c(50, 23, 34, 30, 25))
#knitr::kable(z, booktabs=TRUE)
```

```{r tstablemonth2}
z
```

## The `tsibble` index

\begin{block}{}
For observations more frequent than once per year, we need to use a time class function on the index.
\end{block}

```{r month-tsibble}
z %>%
  mutate(Month = yearmonth(Month)) %>%
  as_tsibble(index = Month)
```

## The `tsibble` index

Common time index variables can be created with these functions:

###
```{r tstable2, echo=FALSE}
tribble(
  ~ `Frequency`, ~ Function,
  "Annual", "`start:end`",
  "Quarterly", "`yearquarter()`",
  "Monthly", "`yearmonth()`",
  "Weekly", "`yearweek()`",
  "Daily", "`as_date()`, `ymd()`",
  "Sub-daily", "`as_datetime()`"
) %>%
  knitr::kable(booktabs=TRUE)
```


## The `key` to many time series

```{r tstablekey}
olympic_running

tsibbledata::olympic_running %>%
  group_by_key() %>%
  slice(1) %>%
  head(6) %>%
  knitr::kable(booktabs=TRUE)
```

## The `key` to many time series

```{r key-tsibble}
olympic_running %>% as_tsibble(
  key = id(Length, Sex), index = Year)
```



### Working with `tsibble` objects {-}

We have used several functions above in order to work with `tsibble` objects, including `mutate()` and `select()`. To illustrate these further, along with some other useful functions, we will use the `PBS` tsibble containing sales data on pharmaceutical products in Australia.

```{r pbs1}
PBS
```

This contains monthly data on Medicare Australia prescription data from July 1991 to June 2008. These are classified according to various concession types, and Anatomical Therapeutic Chemical (ATC) indexes. For this example, we are interested in the `Cost` time series (total cost of scripts in Australian dollars).

We can use the `filter()` function to extract the A10 scripts:

```{r pbs2}
PBS %>%
  filter(ATC2=="A10")
```

This allows rows of the tsibble to be selected. Next we can simplify the resulting object by selecting the columns we will need in subsequent analysis.

```{r pbs3}
PBS %>%
  filter(ATC2=="A10") %>%
  select(Month, Concession, Type, Cost)
```

The `select()` function allows us to select particular columns, while `filter()` allows us to select particular rows.

Note that the index variable `Month` would be returned even if it was not explicitly selected as it is required for a tsibble. If we had not selected the `Concession` and `Type` columns, an error would have occurred because the resulting tsibble would be invalid as there would be duplicate rows for each month.

Another useful function is `summarise()` which allows us to combine data across keys. For example, we may wish to compute total cost per month regardless of the `Concession` or `Type` keys.

```{r pbs4}
PBS %>%
  filter(ATC2=="A10") %>%
  select(Month, Concession, Type, Cost) %>%
  summarise(TotalC = sum(Cost))
```

The new variable `TotalC` is the sum of all `Cost` values for each month.

We can create new variables using the `mutate()` function. Here we change the units from dollars to millions of dollars:

```{r pbs5}
PBS %>%
  filter(ATC2=="A10") %>%
  select(Month, Concession, Type, Cost) %>%
  summarise(TotalC = sum(Cost)) %>%
  mutate(Cost = TotalC/1e6)
```

Finally, we will save the resulting tsibble for examples later in this chapter.

```{r a10}
PBS %>%
  filter(ATC2=="A10") %>%
  select(Month, Concession, Type, Cost) %>%
  summarise(TotalC = sum(Cost)) %>%
  mutate(Cost = TotalC/1e6) -> a10
```

Here we have used the right assignment (`->`) which is convenient at the end of a series of commands like this.

### Read a csv file and convert to a tsibble {-}

Almost all of the data used in this book is already stored as `tsibble` objects. But most data lives in databases, MS-Excel files or csv files, before it is imported into R. So often the first step in creating a tsibble is to read in the data, and then identify the index and key variables.

For example, suppose we have the following daily data stored in a csv file (only the first 10 rows are shown). This data set provides information on the size of the prison population in Australia, disaggregated by state, gender, legal status and indigenous status. (Here, ATSI stands for Aboriginal or Torres Strait Islander.)

```{r prison, echo=FALSE, warning=FALSE, message=FALSE}
prison <- readr::read_csv("../data/prison_population.csv")
prison %>%
  head(10) %>%
  knitr::kable(booktabs=TRUE)
prison <- prison %>%
  mutate(Quarter = yearquarter(date)) %>%
  select(-date) %>%
  as_tsibble(index=Quarter, key=c(state, gender, legal, indigenous))
```

We can read it into R, and create a tsibble object, by simply identifying which column contains the time index, and which columns are keys. The remaining columns are values --- there can be many value columns, although in this case there is only one (`count`). The original csv file stored the dates as individual days, although the data is actually quarterly, so we need to convert the `date` variable to quarters.

```{r prison2, echo=TRUE, eval=FALSE}
prison <- readr::read_csv("https://otexts.com/fpp3/extrafiles/prison_population.csv") %>%
  mutate(Quarter = yearquarter(date)) %>%
  select(-date) %>%
  as_tsibble(index=Quarter, key=c(state, gender, legal, indigenous))
```

```{r prison3, dependson=prison}
prison
```

This tsibble contains 64 separate time series corresponding to the combinations of the 8 states, 2 genders, 2 legal statuses and 2 indigenous statuses. Each of these series is `r NROW(prison)/64` observations in length, from `r head(prison,1)$Quarter` to `r tail(prison,1)$Quarter`.

For a tsibble to be valid, it requires a unique time for each combination of keys. The `tsibble()` or `as_tsibble()` function will return an error if this is not true.

### The seasonal period {-}
<!-- TODO: Also detail problematic periods (months in daily data). -->

Some graphics and some models will use the seasonal period of the data. The seasonal period\index{frequency}\index{period} is the number of observations before the seasonal pattern repeats. In most cases, this will be automatically detected using the time index variable.

Some common periods for different time intervals are shown in the table below:

```{r freqtable, echo=FALSE, message=FALSE}
  intervals <- list(
  Quarters = tsibble::new_interval(quarter = 1),
  Months = tsibble::new_interval(month = 1),
  Weeks = tsibble::new_interval(week = 1),
  Days = tsibble::new_interval(day = 1),
  Hours = tsibble::new_interval(hour = 1),
  Minutes = tsibble::new_interval(minute = 1),
  Seconds = tsibble::new_interval(second = 1)
)

intervals %>%
  purrr::map(common_periods) %>%
  purrr::map(as.list) %>%
  purrr::map_dfr(as_tibble, .id = "Data") %>%
  purrr::set_names(., stringr::str_to_sentence(colnames(.))) %>%
  select(Data, Minute, Hour, Day, Week, Year) %>%
  mutate_all(format, scientific = FALSE, nsmall = 2) %>%
  mutate_all(~ gsub(".00", "", ., fixed = TRUE)) %>%
  mutate_all(~ gsub("   NA", "", ., fixed=TRUE)) %>%
  knitr::kable(booktabs=TRUE)
```

For quarterly, monthly and weekly data, there is only one seasonal period --- the number of observations within each year. Actually, there are not $52$ weeks in a year, but $365.25/7 = `r sprintf("%.2f",365.25/7)`$ on average, allowing for a leap year every fourth year. Approximating seasonal periods to integers can be useful as many seasonal terms in models only support integer seasonal periods.

If the data is observed more than once per week, then there is often more than one seasonal pattern in the data. For example, data with daily observations\index{daily data} might have weekly (period$=7$) or annual (period$=365.25$) seasonal patterns. Similarly, data that are observed every minute might have hourly (period$=60$), daily (period$=24\times60=1440$), weekly (period$=24\times60\times7=10080$) and annual seasonality (period$=24\times60\times365.25=525960$).\index{hourly data}\index{multiple seasonality}\index{sub-daily data}

More complicated (and unusual) seasonal patterns can be specified using the `period()` function in the lubridate package.



## Australian GDP

\fontsize{12}{14}\sf

```{r, echo = TRUE}
aus_economy <- global_economy %>%
  filter(Country == "Australia")
```

```{r, echo=FALSE}
aus_economy
```

## Australian GDP

```{r, echo=TRUE, fig.height=4}
aus_economy %>% autoplot(GDP)
```

# Time plots

## Time plots

\small

```{r, echo=TRUE, fig.height=4}
ansett %>%
  filter(Airports=="MEL-SYD", Class=="Economy") %>%
  autoplot(Passengers)
```

## Time plots

```{r a10-print, echo = FALSE, dependson="a10"}
a10
```


## Time plots

\small

```{r a10-plot, echo=TRUE, dependson="a10"}
a10 %>% autoplot(Cost) +
  ylab("$ million") + xlab("Year") +
  ggtitle("Antidiabetic drug sales")
```

## Your turn

- Create plots of the following time series: Bricks from `aus_production`, Lynx from `pelt`, Google from `gafa_stock`
- Use `help()` to find out about the data in each series.
- For the last plot, modify the axis labels and title.

## Are time plots best?

\fontsize{12}{14}\sf

```{r maxtemp, echo=FALSE}
maxtemp <- vic_elec %>%
  index_by(Day = lubridate::date(Time)) %>%
  summarise(
    Temperature = max(Temperature),
    Demand = sum(Demand),
    Holiday = any(Holiday)
  )
```

```{r maxtemp1, warning=FALSE, message=FALSE, dependson="maxtemp"}
maxtemp %>%
  autoplot(Temperature) +
  xlab("Week") + ylab("Max temperature")
```

## Are time plots best?

\fontsize{12}{14}\sf

```{r maxtemp2, warning=FALSE, message=FALSE, dependson="maxtemp"}
maxtemp %>%
  ggplot(aes(x = Day, y = Temperature)) +
  geom_point() +
  xlab("Week") + ylab("Max temperature")
```

## Are time plots best?

```{r maxtemp3, warning=FALSE, message=FALSE, echo=FALSE, dependson="maxtemp"}
maxtemp %>%
  ggplot(aes(x = Day, y = 1)) +
  geom_tile(aes(fill = Temperature)) +
  scale_fill_gradient2(
    low = "navy",
    mid = "yellow",
   high = "red", midpoint=28) +
  ylab("") + scale_y_discrete(expand=c(0,0))
```

## Are time plots best?

\fullheight{TemperatureBlanket}

